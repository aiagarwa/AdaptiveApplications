# -*- coding: utf-8 -*-
"""Item_Based_Coll_Filtering_Mood_Weather_Ratings.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hGTKAIOyKY1Q7yS_tnycYd77spzVy0YH
"""

from datetime import datetime
import pandas as pd
import numpy as np
import math
import os
import csv
import warnings
import matplotlib.pyplot as plt
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import mean_squared_error
from math import pow, sqrt
import sys
import data_processing

"""Mounting the drive to access the other files"""

# from google.colab import drive 
# drive.mount('/content/gdrive')

# !ls /content/gdrive/My\ Drive/*.py

# sys.path.append('/content/gdrive/My Drive')

# import data_processing # For importing data having processed values of mood and weather

"""Get the historic data from DB or File"""

food_ratings_raw = pd.read_csv('gdrive/My Drive/interactions_with_simulated_data.csv',engine='python')
recipes = pd.read_csv('gdrive/My Drive/recipes_less_data_v3.csv')

"""Process the food ratings for mood and weather"""

food_ratings = data_processing.get_ratings_weather_mood(food_ratings_raw, "sunny", "happy")
food_ratings

"""## Data Exploration Methods"""

def data_exploration(data, weather, mood):
  # recipes = recipes.dropna(subset=['cuisines'])
  # food_ratings.drop(columns=["review"],inplace=True)
  user_ids = food_ratings.user_id.unique().tolist()
  recipe_ids = food_ratings.recipe_id.unique().tolist()
  print('Number of Users: {}'.format(len(user_ids)))
  print('Number of Recipes: {}'.format(len(recipe_ids)))

def showRatingCount(data, feature):
  df_mood_cnt_tmp = pd.DataFrame(data.groupby(feature).size(), columns=['count'])
  ax = df_mood_cnt_tmp[['count']].reset_index().rename(columns={'index': 'Recipe Selection Rating'}).plot(x='rating',y='count',kind='bar',figsize=(12, 8),title='Count for Each Rating Score',fontsize=12)
  ax.set_xlabel("recipe rating score by" + feature)
  ax.set_ylabel("number of ratings")

"""## Methods to generate recommendations

Get User Item Matrix
"""

def get_user_item_matrix(data,feature):
  rating_crosstab = food_ratings.pivot_table(values=feature, index='user_id', columns='recipe_id', fill_value=0)
  return rating_crosstab

"""Get Item Similarity Matrix using cosine distance """

def get_similarity_matrix(usrItmMat):
  # rating_crosstab = food_ratings.pivot_table(values=feature, index='user_id', columns='recipe_id', fill_value=0)
  X = usrItmMat.T
  X = X.replace(['0', 0], np.nan)
  # pivot = X
  pivot_norm = X.apply(lambda x: x+np.nanmean(x), axis=1)
  pivot_norm.fillna(0, inplace=True)
  item_sim_df = pd.DataFrame(cosine_similarity(pivot_norm), index=pivot_norm.index, columns=pivot_norm.index)
  return item_sim_df, pivot_norm

"""Get User Similarity Matrix using cosine distance """

def get_similarity_matrix_user(usrItmMat):
  # rating_crosstab = food_ratings.pivot_table(values=feature, index='user_id', columns='recipe_id', fill_value=0)
  X = usrItmMat
  X = X.replace(['0', 0], np.nan)
  # pivot = X
  pivot_norm = X.apply(lambda x: x+np.nanmean(x), axis=1)
  pivot_norm.fillna(0, inplace=True)
  user_sim_df = pd.DataFrame(cosine_similarity(pivot_norm), index=pivot_norm.index, columns=pivot_norm.index)
  return user_sim_df, pivot_norm

"""Method to get the similar recipes based on ratings of other recipe """

def get_similar_recipe(recipe_id,similarity,usrItmMat):
    Recommendations = pd.DataFrame({'corr_specific':similarity[recipe_id].values, 'Recipe_Id': usrItmMat.columns})\
                        .sort_values('corr_specific', ascending=False)
    return Recommendations['Recipe_Id'][1:].values, Recommendations['corr_specific'].values[1:]

"""Method to get the similar users based on ratings of recipes"""

def get_similar_users(user_id,similarity,usrItmMat):
    Recommendations = pd.DataFrame({'corr_specific':similarity[user_id].values, 'User_Id': usrItmMat.T.columns})\
                        .sort_values('corr_specific', ascending=False)
    # return Recommendations['Recipe_Id'][1:].values, Recommendations['corr_specific'].values[1:] 
    return Recommendations['User_Id'][1:].values, Recommendations['corr_specific'][1:].values

"""Get the predictions of ratings for all recipes for all users"""

# predict the rating of recipe x by user y
def predict_rating(user_id, recipe_id, similarity, usrItmMat, normalized_usrItmMat, max_neighbor=10):
    recipes, scores = get_similar_recipe(recipe_id,similarity,usrItmMat)
    recipe_arr = np.array([x for x in recipes])
    sim_arr = np.array([x for x in scores])

    X = usrItmMat.T
    
    # select only recipe that has already selected by user x
    filtering = normalized_usrItmMat[user_id].loc[recipe_arr] != 0
    
    
    # calculate the predicted score
    s = np.dot(sim_arr[filtering][:max_neighbor], X[user_id].loc[recipe_arr[filtering][:max_neighbor]]) \
            / np.sum(sim_arr[filtering][:max_neighbor])
    s = np.nan_to_num(s)
    return s

# predict the rating of recipe x based on similar users
def predict_rating_user(user_id, recipe_id, similarity, usrItmMat, normalized_usrItmMat, max_neighbor=10):
    users, scores = get_similar_users(user_id,similarity,usrItmMat)
    user_arr = np.array([x for x in users])
    sim_arr = np.array([x for x in scores])
    if normalized_usrItmMat.T[user_id].loc[recipe_id] != 0 and np.sum(usrItmMat[recipe_id].loc[user_arr[:max_neighbor]]) !=0:
      mean_rat=normalized_usrItmMat.T[user_id].mean()
      s = mean_rat+np.dot(sim_arr[:max_neighbor],(usrItmMat[recipe_id].loc[user_arr[:max_neighbor]]-usrItmMat.loc[user_arr[:max_neighbor]].mean(axis=1))) \
                    /np.sum(usrItmMat[recipe_id].loc[user_arr[:max_neighbor]])
      # print(s)
      return s
    else:
      return 0

"""Get the recommendations of similar food items based on different features"""

def get_recommendation(user_id,food_ratings,feature="rating",max_neighbors=10, type="item"):
    warnings.filterwarnings("ignore", category=RuntimeWarning)
    
    usrItmMat = get_user_item_matrix(food_ratings,feature)
    # return sim_Mat

    rids = food_ratings.recipe_id.unique().tolist()

    predicted_rating = {}
    
    if type=="user":    
      sim_Mat, normalized_usrItmMat = get_similarity_matrix_user(usrItmMat)
      for _recipe in rids:
          rating = predict_rating_user(user_id, _recipe, sim_Mat, usrItmMat, normalized_usrItmMat)
          predicted_rating[_recipe] = rating
    else:
      sim_Mat, normalized_usrItmMat = get_similarity_matrix(usrItmMat)
      for _recipe in rids:
          rating = predict_rating(user_id, _recipe, sim_Mat, usrItmMat, normalized_usrItmMat)
          predicted_rating[_recipe] = rating
    
    a = sorted(predicted_rating.items(), key=lambda x: x[1], reverse=True)
    df_rec = pd.DataFrame(a, columns =['recipe_id', 'pred_rating'])
    return df_rec

    # # don't recommend something that user has already rated
    # temp = pd.DataFrame({'predicted':predicted_rating, 'name':rids})
    # filtering = (pivot_norm[user_id] == 0.0)
    # temp = temp.sort_values(by='predicted', ascending=False)

    # recommend n_recipe recipe
    # return recipe.loc[anime_index.loc[temp.name[:10]]]

"""Method to filter the recipes according to filtering conditions"""

def filter_top_recipes(pred_ratings_feature, filtering=[], allergies =[]):
  filterRecipes = recipes;
  if len(filtering) == 0 and len(allergies) == 0:
    return pred_ratings_feature
  for f in filtering:
    if f == "vegetarian":
      filterRecipes = filterRecipes[filterRecipes["vegetarian"] == 1]
    elif f.startswith("cooking_time_less_than"):
      mins = int(f.split("_")[-1])
      filterRecipes = filterRecipes[filterRecipes["minutes"] <= mins]
      
  for allergy in allergies:
    filterRecipes = filterRecipes[filterRecipes[allergy + "_allergic"] == 0]

  return pred_ratings_feature[pred_ratings_feature.recipe_id.isin(filterRecipes.id.values)]

"""Method to get the list of ratings of top 5 recipes in each feature for all the features """

def get_ratings_of_top_rec_by_feaures(pred_ratings_feature1, pred_rating_feature2, pred_rating_feature3, filtering=[], allergies=[]):

  pred_ratings_feature1=filter_top_recipes(pred_ratings_feature1, filtering, allergies)
  pred_rating_feature2=filter_top_recipes(pred_rating_feature2, filtering, allergies)
  pred_rating_feature3=filter_top_recipes(pred_rating_feature3, filtering, allergies)

  top_pred_ratings_feature1=pred_ratings_feature1.head()
  rec_list1 = top_pred_ratings_feature1.values.tolist()
  rec_list1=[[int(i[0]),i[1]] for i in rec_list1]
  for r in pred_rating_feature2.head()["recipe_id"].values:
    if r not in top_pred_ratings_feature1["recipe_id"].values:
      temp = pred_ratings_feature1.index[pred_ratings_feature1['recipe_id']== r]
      rec_list1.append([r,pred_ratings_feature1.at[temp[0],'pred_rating']])

  for r in pred_rating_feature3.head()["recipe_id"].values:
    if r not in top_pred_ratings_feature1["recipe_id"].values:
      temp = pred_ratings_feature1.index[pred_ratings_feature1['recipe_id']== r]
      rec_list1.append([r,pred_ratings_feature1.at[temp[0],'pred_rating']])
  return rec_list1

"""Calculate the weighted score of every feature and filter out the common top 3 recommended recipes by all features for a user"""

def get_coll_recommendations(user_id, weather, mood, filtering=[], allergies=[]):

# Item Similarity
  # Get the recommendations by each feature for a user
  rec_by_mood = get_recommendation(user_id,food_ratings,mood,max_neighbors=10)
  rec_by_weather = get_recommendation(user_id,food_ratings,weather,max_neighbors=10)
  rec_overall_selection = get_recommendation(user_id,food_ratings,"rating",max_neighbors=10)

  # Add the top 5 recommended recipes and their scores from each feature to the other features list 
  # so that all the lists contains same recipes and their scores
  get_all_mood_scores = get_ratings_of_top_rec_by_feaures(rec_by_mood,rec_by_weather,rec_overall_selection, filtering, allergies)
  get_all_weather_scores = get_ratings_of_top_rec_by_feaures(rec_by_weather,rec_by_mood,rec_overall_selection, filtering, allergies)
  get_all_overall_selection_scores = get_ratings_of_top_rec_by_feaures(rec_overall_selection,rec_by_mood,rec_by_weather, filtering, allergies)

  # Calculate the weighted scores for all recipes in recommended recipe list of each feature
  rbm_weighted = list(map(lambda x: (x[0],x[1] * 0.4), get_all_mood_scores))
  rbw_weighted = list(map(lambda x: (x[0],x[1] * 0.3), get_all_weather_scores))
  ros_weighted = list(map(lambda x: (x[0],x[1] * 0.3), get_all_overall_selection_scores))

  # Sort the lists by recipe id
  rbm_weighted = sorted(rbm_weighted, key=lambda x: x[0])
  rbw_weighted = sorted(rbw_weighted, key=lambda x: x[0])
  ros_weighted = sorted(ros_weighted, key=lambda x: x[0])

  # Add the weighted scores of each recipe from all the lists 
  combined_rec = [[lm[0], lm[1] + lw[1] + los[1]] for lm, lw, los in zip(rbm_weighted, rbw_weighted, ros_weighted)]

  # Sort the list
  combined_rec = sorted(combined_rec, key=lambda x: x[1], reverse=True)
  rec_list_items = pd.DataFrame(combined_rec[:3],columns=["recipe_id","pred_rating"])

# User Similarity
  user_recomm = get_recommendation(user_id,food_ratings,feature="rating",max_neighbors=10, type="user")
  user_recomm = filter_top_recipes(user_recomm, filtering)
  user_rec_list = user_recomm[:3]


  return rec_list_items, user_rec_list
  # return rbm_weighted, rbw_weighted, ros_weighted

"""Get the recipe name from recipe id"""

def get_recipe_name_(recipeid):
    temp = recipes.index[recipes['id']== recipeid]
    return recipes.at[temp[0],'name'], recipes.at[temp[0],'cuisines']

"""Method to return the recommended Recipe Names and related cuisine type and score"""

def get_recipe_names_for_all_recommendations(recommended_list):
  recommendations = []
  for item in recommended_list:
        name,cuisine = get_recipe_name_(item[0])
        if name == "":
          pass
        else:
          recommendations.append([name,cuisine,item[1]])
  recommended_food = pd.DataFrame(recommendations,columns=["Recipe","Cuisine Type","score"])
  return recommended_food

"""Method to get all the recommendations"""

def get_all_recommendations(user_id, weather, mood, filtering=[], allergies=[]):
  sim_item_recom, sim_user_recom = get_coll_recommendations(user_id, weather, mood, filtering, allergies)
  # sim_item_recom = get_coll_recommendations(user_id, weather, mood, filtering)
  all_rec = {"Mood Weather Ratings Recommendations":sim_item_recom, "Similar User Recommendations":sim_user_recom}
  return all_rec

"""## Recommended System Evaluation Methods"""

def predict(ratings, similarity):
  mean_user_rating = ratings.mean(axis=1)
  # Use np.newaxis so that mean_user_rating has same format as ratings
  ratings_diff = (ratings - mean_user_rating[:, np.newaxis])
  pred = mean_user_rating[:, np.newaxis] + similarity.dot(ratings_diff) / np.array([np.abs(similarity).sum(axis=1)]).T
  return pred

# Function to calculate RMSE
def rmse(pred, actual):
    # Ignore nonzero terms.
    pred = pred[actual.nonzero()].flatten()
    actual = actual[actual.nonzero()].flatten()
    return sqrt(mean_squared_error(pred, actual))

def evaluate(usrItemMat,similarity):
  actual = usrItemMat.to_numpy()
  item_prediction = predict(actual, similarity.to_numpy())
  print('Item-based CF RMSE: ' + str(rmse(item_prediction, actual))) 
  # actual=np.nan_to_num(actual)

# Example
combined_rec=get_all_recommendations(491979,"sunny","happy", filtering=["vegetarian", "cooking_time_less_than_30"], allergies = ["dairy", "fish"])

combined_rec
