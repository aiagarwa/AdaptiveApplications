# -*- coding: utf-8 -*-
"""Item_Based_Coll_Filtering_Mood_Weather_Ratings.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hGTKAIOyKY1Q7yS_tnycYd77spzVy0YH
"""

from datetime import datetime
import pandas as pd
import numpy as np
import math
import os
import csv
import warnings
import matplotlib.pyplot as plt
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import mean_squared_error
from math import pow, sqrt
import sys

"""Mounting the drive to access the other files"""

# from google.colab import drive 
# drive.mount('/content/gdrive')

# !ls /content/gdrive/My\ Drive/*.py

# sys.path.append('/content/gdrive/My Drive')

# import data_processing # For importing data having processed values of mood and weather

"""Get the historic data from DB or File"""

food_ratings_raw = pd.read_csv('gdrive/My Drive/interactions_with_simulated_data.csv',engine='python')
recipes = pd.read_csv('gdrive/My Drive/recipes_less_data_v3.csv')

"""Process the food ratings for mood and weather"""

food_ratings = data_processing.get_ratings_weather_mood(food_ratings_raw, "sunny", "happy")
food_ratings

"""## Data Exploration Methods"""

def data_exploration(data, weather, mood):
  # recipes = recipes.dropna(subset=['cuisines'])
  # food_ratings.drop(columns=["review"],inplace=True)
  user_ids = food_ratings.user_id.unique().tolist()
  recipe_ids = food_ratings.recipe_id.unique().tolist()
  print('Number of Users: {}'.format(len(user_ids)))
  print('Number of Recipes: {}'.format(len(recipe_ids)))

def showRatingCount(data, feature):
  df_mood_cnt_tmp = pd.DataFrame(data.groupby(feature).size(), columns=['count'])
  ax = df_mood_cnt_tmp[['count']].reset_index().rename(columns={'index': 'Recipe Selection Rating'}).plot(x='rating',y='count',kind='bar',figsize=(12, 8),title='Count for Each Rating Score',fontsize=12)
  ax.set_xlabel("recipe rating score by" + feature)
  ax.set_ylabel("number of ratings")

"""## Methods to generate recommendations

Get User Item Matrix
"""

def get_user_item_matrix(data,feature):
  rating_crosstab = food_ratings.pivot_table(values=feature, index='user_id', columns='recipe_id', fill_value=0)
  return rating_crosstab

"""Get Similarity Matrix using cosine distance """

def get_similarity_matrix(usrItmMat):
  # rating_crosstab = food_ratings.pivot_table(values=feature, index='user_id', columns='recipe_id', fill_value=0)
  X = usrItmMat.T
  X = X.replace(['0', 0], np.nan)
  # pivot = X
  pivot_norm = X.apply(lambda x: x+np.nanmean(x), axis=1)
  pivot_norm.fillna(0, inplace=True)
  item_sim_df = pd.DataFrame(cosine_similarity(pivot_norm), index=pivot_norm.index, columns=pivot_norm.index)
  return item_sim_df, pivot_norm

"""Method to get the similar recipes based on other recipe """

def get_similar_recipe(recipe_id,similarity,usrItmMat):
    Recommendations = pd.DataFrame({'corr_specific':similarity[recipe_id].values, 'Recipe_Id': usrItmMat.columns})\
                        .sort_values('corr_specific', ascending=False)
    return Recommendations['Recipe_Id'][1:].values, Recommendations['corr_specific'].values[1:]

"""Get the predictions of ratings for all recipes for all users"""

# predict the rating of recipe x by user y
def predict_rating(user_id, recipe_id, similarity, usrItmMat, normalized_usrItmMat, max_neighbor=10):
    recipes, scores = get_similar_recipe(recipe_id,similarity,usrItmMat)
    recipe_arr = np.array([x for x in recipes])
    sim_arr = np.array([x for x in scores])

    X = usrItmMat.T
    
    # select only recipe that has already selected by user x
    filtering = normalized_usrItmMat[user_id].loc[recipe_arr] != 0
    
    
    # calculate the predicted score
    s = np.dot(sim_arr[filtering][:max_neighbor], X[user_id].loc[recipe_arr[filtering][:max_neighbor]]) \
            / np.sum(sim_arr[filtering][:max_neighbor])
    s = np.nan_to_num(s)
    return s

"""Get the recommendations of similar food items based on different features"""

def get_recommendation(user_id,food_ratings,feature="rating",n_recipe=10):
    warnings.filterwarnings("ignore", category=RuntimeWarning)
    
    usrItmMat = get_user_item_matrix(food_ratings,feature)
    sim_Mat, normalized_usrItmMat = get_similarity_matrix(usrItmMat)
    # return sim_Mat

    rids = food_ratings.recipe_id.unique().tolist()

    predicted_rating = {}
    
    for _recipe in rids:
        rating = predict_rating(user_id, _recipe, sim_Mat, usrItmMat, normalized_usrItmMat)
        predicted_rating[_recipe] = rating
    
    a = sorted(predicted_rating.items(), key=lambda x: x[1], reverse=True)
    df_rec = pd.DataFrame(a, columns =['recipe_id', 'pred_rating'])
    return df_rec

    # # don't recommend something that user has already rated
    # temp = pd.DataFrame({'predicted':predicted_rating, 'name':rids})
    # filtering = (pivot_norm[user_id] == 0.0)
    # temp = temp.sort_values(by='predicted', ascending=False)

    # recommend n_recipe recipe
    # return recipe.loc[anime_index.loc[temp.name[:10]]]

"""Method to get the list of ratings of top 5 recipes in each feature for all the features """

def get_ratings_of_top_rec_by_feaures(pred_ratings_feature1, pred_rating_feature2, pred_rating_feature3):
  top_pred_ratings_feature1=pred_ratings_feature1.head()
  rec_list1 = top_pred_ratings_feature1.values.tolist()
  rec_list1=[[int(i[0]),i[1]] for i in rec_list1]
  for r in pred_rating_feature2.head()["recipe_id"].values:
    if r not in top_pred_ratings_feature1["recipe_id"].values:
      temp = pred_ratings_feature1.index[pred_ratings_feature1['recipe_id']== r]
      rec_list1.append([r,pred_ratings_feature1.at[temp[0],'pred_rating']])

  for r in pred_rating_feature3.head()["recipe_id"].values:
    if r not in top_pred_ratings_feature1["recipe_id"].values:
      temp = pred_ratings_feature1.index[pred_ratings_feature1['recipe_id']== r]
      rec_list1.append([r,pred_ratings_feature1.at[temp[0],'pred_rating']])
  return rec_list1

"""Calculate the weighted score of every feature and filter out the common top 3 recommended recipes by all features for a user"""

def get_coll_recommendations(user_id, weather, mood):

  # Get the recommendations by each feature for a user
  rec_by_mood = get_recommendation(user_id,food_ratings,mood,n_recipe=10)
  rec_by_weather = get_recommendation(user_id,food_ratings,weather,n_recipe=10)
  rec_overall_selection = get_recommendation(user_id,food_ratings,"rating",n_recipe=10)

  # Add the top 5 recommended recipes and their scores from each feature to the other features list 
  # so that all the lists contains same recipes and their scores
  get_all_mood_scores = get_ratings_of_top_rec_by_feaures(rec_by_mood,rec_by_weather,rec_overall_selection)
  get_all_weather_scores = get_ratings_of_top_rec_by_feaures(rec_by_weather,rec_by_mood,rec_overall_selection)
  get_all_overall_selection_scores = get_ratings_of_top_rec_by_feaures(rec_overall_selection,rec_by_mood,rec_by_weather)

  # Calculate the weighted scores for all recipes in recommended recipe list of each feature
  rbm_weighted = list(map(lambda x: (x[0],x[1] * 0.4), get_all_mood_scores))
  rbw_weighted = list(map(lambda x: (x[0],x[1] * 0.3), get_all_weather_scores))
  ros_weighted = list(map(lambda x: (x[0],x[1] * 0.3), get_all_overall_selection_scores))

  # Sort the lists by recipe id
  rbm_weighted = sorted(rbm_weighted, key=lambda x: x[0])
  rbw_weighted = sorted(rbw_weighted, key=lambda x: x[0])
  ros_weighted = sorted(ros_weighted, key=lambda x: x[0])

  # Add the weighted scores of each recipe from all the lists 
  combined_rec = [[lm[0], lm[1] + lw[1] + los[1]] for lm, lw, los in zip(rbm_weighted, rbw_weighted, ros_weighted)]

  # Sort the list
  combined_rec = sorted(combined_rec, key=lambda x: x[1], reverse=True)

  return combined_rec[:3]
  # return rbm_weighted, rbw_weighted, ros_weighted

"""Get the recipe name from recipe id"""

def get_recipe_name_(recipeid):
    temp = recipes.index[recipes['id']== recipeid]
    return recipes.at[temp[0],'name'], recipes.at[temp[0],'cuisines']

"""Method to return the recommended Recipe Names and related cuisine type and score"""

def get_recipe_names_for_all_recommendations(recommended_list):
  recommendations = []
  for item in recommended_list:
        name,cuisine = get_recipe_name_(item[0])
        if name == "":
          pass
        else:
          recommendations.append([name,cuisine,item[1]])
  recommended_food = pd.DataFrame(recommendations,columns=["Recipe","Cuisine Type","score"])
  return recommended_food

"""## Recommended System Evaluation Methods"""

def predict(ratings, similarity):
  mean_user_rating = ratings.mean(axis=1)
  # Use np.newaxis so that mean_user_rating has same format as ratings
  ratings_diff = (ratings - mean_user_rating[:, np.newaxis])
  pred = mean_user_rating[:, np.newaxis] + similarity.dot(ratings_diff) / np.array([np.abs(similarity).sum(axis=1)]).T
  return pred

# Function to calculate RMSE
def rmse(pred, actual):
    # Ignore nonzero terms.
    pred = pred[actual.nonzero()].flatten()
    actual = actual[actual.nonzero()].flatten()
    return sqrt(mean_squared_error(pred, actual))

def evaluate(usrItemMat,similarity):
  actual = usrItemMat.to_numpy()
  item_prediction = predict(actual, similarity.to_numpy())
  print('Item-based CF RMSE: ' + str(rmse(item_prediction, actual))) 
  # actual=np.nan_to_num(actual)

# Example
combined_rec=get_coll_recommendations(491979,"sunny","happy")

combined_rec

rec_list = get_recipe_names_for_all_recommendations(combined_rec)
rec_list