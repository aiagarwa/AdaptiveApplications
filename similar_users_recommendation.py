# -*- coding: utf-8 -*-
"""UserModeling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15o4QQUsZrZJ6_9XSNMoyxYiRTCnODCL6
"""

import pandas as pd
from math import pow, sqrt

# from google.colab import drive 
# drive.mount('/content/gdrive')

food_ratings = pd.read_csv('gdrive/My Drive/RAW_interactions_remove_empty_cuisine_type.csv',engine='python')
food_ratings.head()

user_ids = food_ratings.user_id.unique().tolist()
recipe_ids = food_ratings.recipe_id.unique().tolist()
print('Number of Users: {}'.format(len(user_ids)))
print('Number of Recipes: {}'.format(len(recipe_ids)))

recipes = pd.read_csv('gdrive/My Drive/RAW_recipes_with_new_columns.csv')
recipes.head()

recipes = recipes.dropna()

cuisine_types = recipes.cuisines.unique().tolist()
print('Unique Cuisines: {}'.format(cuisine_types))

# recipes = pd.get_dummies(recipes, columns=["cuisines"])
# recipes.head()

def get_rating_(userid,recipeid):
    return (food_ratings.loc[(food_ratings.user_id==userid) & (food_ratings.recipe_id == recipeid),'rating'].iloc[0])

def get_recipeids_(userid):
    return (food_ratings.loc[(food_ratings.user_id==userid),'recipe_id'].tolist())

recipes.reset_index(drop=True,inplace=True)

def get_recipe_name_(recipeid):
    temp = recipes.index[recipes['id']== recipeid]
    return recipes.at[temp[0],'name'], recipes.at[temp[0],'cuisines'] 

# def get_recipe_name_(recipeid):
#     return (recipes.loc[(recipes.id == recipeid),'name'].iloc[0])

def pearson_correlation_score(user1,user2):
    '''
    user1 & user2 : user ids of two users between which similarity score is to be calculated.
    '''
    # A list of recipes selected by both the users.
    both_selected_count = []
    
    # Finding recipes selected  by both the users.
    for element in food_ratings.loc[food_ratings.user_id==user1,'recipe_id'].tolist():
        if element in food_ratings.loc[food_ratings.user_id==user2,'recipe_id'].tolist():
            both_selected_count.append(element)

    # Returning '0' correlation for bo common movies.
    if len(both_selected_count) == 0 :
        return 0
    
    # Calculating Co-Variances.
    rating_sum_1 = sum([get_rating_(user1,element) for element in both_selected_count])
    rating_sum_2 = sum([get_rating_(user2,element) for element in both_selected_count])
    rating_squared_sum_1 = sum([pow(get_rating_(user1,element),2) for element in both_selected_count])
    rating_squared_sum_2 = sum([pow(get_rating_(user2,element),2) for element in both_selected_count])
    product_sum_rating = sum([get_rating_(user1,element) * get_rating_(user2,element) for element in both_selected_count])
    
    # Returning pearson correlation between both the users.
    numerator = product_sum_rating - ((rating_sum_1 * rating_sum_2) / len(both_selected_count))
    denominator = sqrt((rating_squared_sum_1 - pow(rating_sum_1,2) / len(both_selected_count)) * (rating_squared_sum_2 - pow(rating_sum_2,2) / len(both_selected_count)))
    # Handling 'Divide by Zero' error.
    if denominator == 0:
        return 0
    return numerator/denominator
# print('Pearson Corelation between user ids 11 & 30: {}'.format(pearson_correlation_score(394077,280271)))

def most_similar_users_(user1,number_of_users,metric='pearson'):
    '''
    user1 : Targeted User
    number_of_users : number of most similar users you want to user1.
    metric : metric to be used to calculate inter-user similarity score. ('pearson' or else)
    '''
    # Getting distinct user ids.
    user_ids = food_ratings.user_id.unique().tolist()
    
    # Getting similarity score between targeted and every other suer in the list(or subset of the list).
    if(metric == 'pearson'):
        similarity_score = [(pearson_correlation_score(user1,nth_user),nth_user) for nth_user in user_ids[:100] if nth_user != user1]
    else:
        similarity_score = [(distance_similarity_score(user1,nth_user),nth_user) for nth_user in user_ids[:100] if nth_user != user1]
    
    # Sorting in descending order.
    similarity_score.sort()
    similarity_score.reverse()
    
    # Returning the top most 'number_of_users' similar users. 
    return similarity_score[:number_of_users]
# print(most_similar_users_(394077,5,metric='pearson'))

def get_recommendation_(userid):
    user_ids = food_ratings.user_id.unique().tolist()
    total = {}
    similariy_sum = {}
    recommendations = []
    
    # Iterating over subset of user ids.
    for user in user_ids[:100]:
        
        # not comparing the user to itself (obviously!)
        if user == userid:
            continue
        
        # Getting similarity score between the users.
        score = pearson_correlation_score(userid,user)

        # print(score)
        
        # not considering users having zero or less similarity score.
        if score <= 0:
            continue
        
        # Getting weighted similarity score and sum of similarities between both the users.
        for recipeid in get_recipeids_(user):
            # Only considering not selected recipes
            if recipeid not in get_recipeids_(userid) or get_rating_(userid,recipeid) == 0:
                total[recipeid] = 0
                total[recipeid] += get_rating_(user,recipeid) * score
                similariy_sum[recipeid] = 0
                similariy_sum[recipeid] += score
    
    # Normalizing ratings
    ranking = [(tot/similariy_sum[recipeid],recipeid) for recipeid,tot in total.items()]
    ranking.sort()
    ranking.reverse()
    # print(ranking)
    # Getting recipe titles against the recipe ids.
    for score,recipeid in ranking:
      name,cuisine = get_recipe_name_(recipeid)
      if name == "":
        pass
      else:
        recommendations.append([name,cuisine])
    return recommendations[:20]
rec = get_recommendation_(394077)

recommended_food = pd.DataFrame(rec,columns=["Recipe","Cuisine Type"])
recommended_food